
## CSS
## css选择器的访问顺序
1. 访问顺序：从右到左(就近原则);（CSS 的后代选择器本身就是一种在标准里面不那么推荐的方式。）
    - 采用 left-to-right 的方式读取css规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取 right-to-left 的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。
2. 扩展
    - 样式种类
        - 外联样式表：在head便签中 用link标签的href属性来引用后缀名为.css的css样式文件
        - 内联样式表：在head标签下的style标签中，选择器 + 样式声明
        - 内部样式表：在标签的style属性中添加css样式声明
    - 加载顺序
        - 外部样式）External style sheet <（内部样式）Internal style sheet <（内联样式）Inline style
        - 如果挖补样式放在内部样式后后面，则外部样式会覆盖内部样式
    - 优先级
        - 内联样式->ID选择器-class选择器->Html标签选择器
        - !important 最大优先级

## CSS的伪类和伪元素

1. W3C定义

   - CSS伪类用于向某些选择器添加特殊效果

     - :active :focus : hover :link visited :first-child :lang(允许创作者来定义指定元素中使用的语言)

   - CSS伪元素用于将特殊的效果加到某些选择器

     - :first-letter first-line :before :after
   
2. 写法（W3C）
    - 伪类用一个冒号
- 伪元素用两个冒号（::after ::before）

## 如何让div 的高度是浏览器高度
1. 直接vh
```css
div{
  height: 100vh;
}
```
2. fixed
```css
div{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
```
3. absolute
```css
div{
  	position: absolute;
    top: 0;
    right: 0;
    left: 0;
    bottom: 0;
}
```
4. height
```css
html,body{
  heght:100%
}
div{
  height:100%
}
```

# 移动端
## 移动端怎么适配刘海屏
1. IOS [参考链接](https://www.jb51.net/html5/667263.html)
    - 官方文档添加meta信息
    ```html
    <!-- 
        viewport-fit
        contain: 可视窗口完全包含网页内容    
        auto默认：viewprot-fit:contain;页面内容显示在safe area内
        cover： viewport-fit:cover,页面内容充满屏幕
    -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    ```
    ```css
        /*
        iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：
        safe-area-inset-left：安全区域距离左边边界距离
        safe-area-inset-right：安全区域距离右边边界距离
        safe-area-inset-top：安全区域距离顶部边界距离
        safe-area-inset-bottom：安全区域距离底部边界距离
        注意：部分浏览器已经不支持constant函数，用env函数替代
        */
    body {
        padding: 12px;
        padding-left: env(safe-area-inset-left);
        padding-left: const(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        padding-right: const(safe-area-inset-right);       
    }
    ```
2. Android [参考链接](https://www.jianshu.com/p/561f7241153b/)
    - 有状态栏，不需要适配
    - 跟原生配合获取刘海高度

## 移动端做过什么优化

1. 影响网站加载速度缓慢的原因
   - 服务器过慢
   - 浏览器缓存（未很好利用浏览器缓存）
   - 文件大小
   - HTTP请求，下载的资源过多，执行三次握手消耗过多时间
   - DNS查询
   - CDN请求（跨域地理位置）
   - 网络自身过慢
   
2. 优化方案 [分析工具](https://github.com/pod4g/hiper)

   - 静态资源离线方案；可以设置离线文件或离线包机制让静态资源请求从本地读取，加快资源载入速度，并实现离线更新。

   - 加载优化（手机浏览器**同时响应请求**为4个请求（Android支持4个，iOS 5后可支持6个））
     - CSS Sprites 精灵图，将多个图片合成一个图片
     - 使用 MediaQuery 或 srcset 根据不同屏幕加载不同大小图片
     - 字体图标
     - 合并CSS和JS
     - LazyLoad懒加载，等到用户真正需要再加载
     - 缓存
       - 使用 Cache-Control、Expires、Etag 和 Last-Modified 来设置 HTTP 缓存，还可以使用 localStorage 等来保存从接口返回的数据，
       - 缓存一切可缓存的资源
       - 使用长cache
       - 外联引用CSS、JavaScript
     
    - 压缩

       -  CSS、JavaScript、HTML（注释、多余空格）
       -  服务端启用GZip
       
    - 按需加载
      
      - 滚屏加载
      - 通过Media Query加载
      
    - 避免重定向

    - 控制资源文件加载优先级

       - CSS写在头部，JavaScript写在尾部或异步。
       - 避免图片和iFrame等的空Src，空Src会**重新加载当前页面，影响速度和效率**
    - 图片优化
        - 避免使用DataURL，DataURl没有使用图片的压缩算法，文件会变大，并且需要解码后再渲染
        - 选择合适的图片格式（webP优于JPG，PNG8优于Gif）
    - CSS优化
        - 尽量避免在HTML中使用style属性。（因为在HTML中使用style会阻塞页面的渲染）
        - 不滥用float（float渲染时计算量比较大）
        - 不滥用web字体（web字体需要下载、解析、重绘当前页面）
        - 不声明过多的font-size。（过多的font-size引发CSS树的效率）
    - JS优化
      
        - 缓存**DOM的选择与计算**，避免每次Dom选择都要重新计算。
        
            - 尽量使用**ID选择器**，ID选择器是最快的。（因为用id访问时，只要找到元素就停止在DOM上查找；而用其他选择器去查找元素则要对DOM所有节点都访问一遍。）
            - 减少**重绘和回流**
            - 避免不必要的**DOM操作**
            - 避免使用**document.write**
            - 尽量**改变Class而不是Style**
            - 使用 touchstart 代替 click（移动端 touchstart 事件和 click 事件触发时间之间存在 300 毫秒的延时）
        - 动画优化
            - 尽量使用CSS3的动画
            - 合理使用requestAnimationFrame动画代替setTimeout。
            - GPU加速（CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用。注意：过渡使用这些属性，会引发手机过度耗电）
        
            

 # 服务端
 ## export default 和export的区别
 1. 概念：export与export default都可以用于导出常量、函数、文件、模块等，我们可以通过在其它文件或模块中import(常量、函数、文件、模块)的方式导入.
 2. 区别
    - export default是唯一的（匿名导出）
    - export可以是多个（具名导出）
3. 注意
    - 可以通过as 重命名
    - 必须在其他语句或者函数之外使用，否则会报错；
## exports 和 module.exports的区别
1. 概念：exports是module.exports的一个引用，exports=module.exports={}
2. 注意：
    - module.exports=xxx，相当于导出某个函数，在另一个文件中引用后可直接调用
    - exports.xxx和module.exports.xxx相当于把函数或变量挂载在对象上，在另一个文件中应用后，通过调用对象属性和方法进行使用
## require 方法的加载规则
1. 加载顺序
    - 优先从缓存中加载
    - 核心模块
    - 路径形式的模块
    - 第三方模块
2. 注意
    - 所有模块第一次加载完毕以后都会有缓存，第二次加载直接读取缓存，避免了二次开销（因为有缓存，所以模块中的代码只在第一次加载的时候执行一次）
    - 同步加载
​    

      



